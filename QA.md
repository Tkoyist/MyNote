# Vue与React

###### Vue与React的技术选型？

###### 虚拟DOM与真实DOM的性能对比

​	虚拟dom大多数时候比真实dom更快，但是有些时候真实DOM会更快，但是虚拟DOM更稳定，即使一次性需要修改很多dom，性能的变化也不会太大。

###### React与Vue 的异同

+ 相同点

  + 虚拟dom 的使用
  + 组件化思想的实现
  + 都是由数据驱动视图
  + 都是视图数据层框架
  + 都是单向数据流

+ 不同点

  说到不同点，两者在细枝末节上的不同点很多，但是个人认为产生这些不同的原因本质上都是设计思想与发展理念的不同，React推崇函数式编程，同时将逻辑融入了结构与样式，使得我们可以通过JavaScript的逻辑对结构和样式进行处理，这给予了我们很高的自由度，在开发工作者个人能力足够的前提下，可以自己根据场景选择合适的开发模式，而Vue的创始者最初的一个核心思想就是降低框架的学习成本，降低前端开发的门槛，因此他将结构，逻辑与样式完全区分开，这样对于刚接触框架的程序员来说，显然是十分友好的，这也导致了它没有React那么高的自由度，但是在现在Vue飞速发展的过程当中，对大量功能的实现，React的自由度的优势也在逐渐丧失

  + 响应式原理的不同

    + vue 的响应式原理通过递归监听data 中的所有数据（所有，包括嵌套数据，以及对象或者数组当中新添加的数据）一次性对所有数据进行监听，在数据发生改变时，通过get 收集到的依赖（存储在dep数组当中）自动寻找到对应的组件，然后对组件进行diff再渲染更新
    + 而React 的更新是基于状态机的，通过开发工作者自己选择更新时机与更新方式来实现优化，当改变state的时候，以state所在的组件为根目录直接进行diff

  + Vue是双向数据绑定，而React是单向

    Vue是将数据与视图（Dom）进行了双向绑定的，视图的变化都会自动反应到数据当中。但是React的数据更改不会自动响应到视图，需要手动调用setState进行页面更新。

## Vue

######  vue中子父传值、兄弟传值或者没有关联的组件的传值怎么传 

+ 父传子通过props 向子组件传递数据
+ 子传父通过发射事件携带数据传递
+ 没有关联的组件通过vuex状态管理器（React通过Redux实现，所有数据都保存在这里，即单一数据源，要用你直接拿就行，两者的使用也很接近）

######  vuex了解多少，基本功能 

+ vuex类似于redux，是一个单一数据源的状态管理容器。集中存储应用当中所有组件的状态，用于解决多组件之前的通信

###### 事件总线讲一讲

+ 事件总线类似于一趟在组件间来回走动的公交车，每个组件都可以往内部添加事件，也都可以获取内部被运送的事件，我们可以通过它完成跨度较大的组件间的事件通信

######  vuerouter路由守卫介绍一下 

+ 先说作用，用户进入一个主页之后，如果想要进入某个路由页面，我们需要确保当前用户具备进入路由页面的权限。这也就是路由守卫的产生背景。

+ 我对路由守卫的理解，它就像我们常说的钩子函数，钩在了路由跳转的各个阶段，使得我们可以在路由跳转的过程中完成一些我们需要的逻辑，判断

######  axios请求响应拦截器具体怎么写的 

+ 具体的不记得了，但是其核心思想其实也是和钩子函数差不多的

######  vue有没有遇过数据更新但是页面没更新的情况？怎么解决的 

######  vue相比传统的框架优势在哪 

+ 轻量级，渐进式框架，组件化开发自不必说，组件内部的逻辑 结构 样式的分离，减少了程序员的学习代价，同时也具备更高的可阅读性，注意虚拟dom的概念是由React 提出的
+ 渐进式框架，自顶向上增量开发，可以更快的在一个纯js项目中引入vue，因此更易被接受
+ 双向的数据绑定，在数据改变时可以自动映射到视图中
+ 组件更新策略，在React当中，组件的更新会导致下层组件全部更新，当然React提出了PureComponent等一系列方式避免更新无需更新的组件，但是在Vue 当中，这个问题被数据的自动最终解决了，通过getter当中的依赖收集，系统知道需要更新什么组件。开发者无需关注这个问题
+ Vue的各种协同工作库都是由官方进行维护与更新的，这也意味着更加集中的生态系统，与之相对的，React的协同库几乎全部由社区维护，相对分散
+ 灵活性：Vue几乎没有给用户任何限制（注意与自由度区分开）

######  vue怎么拿dom元素 

+ dom 的即用API自不用说

+ ref，为一个dom元素绑定ref属性，然后通过 this(指向当前vue实例).$refs.name(name即dom元素的ref标签值)直接获取到指定的dom元素进行操作

######  Vue中data为什么要是一个函数 

+ 如果data是一个对象的话，我们在不同的位置使用同一个组件，他们所使用data 将会是同一个对象，相当于浅拷贝的对象，这显然是不行的，所以我们需要为每个组件实例准备单独data对象，vue就通过调用一个函数返回对象的方式实现了这一目的

######  插槽用过吗，介绍一下 

+ 我们在使用组件的时候，经常会出现需要使用某个组件，但是又需要动态的添加一些内容的情况，例如商品的展示，我们并不知道到底需要展示多少商品，需要动态的决定，这时候就需要插槽这样的东西，能让我们使用组件的时候动态的决定在什么位置插入什么东西，插槽就是这样一个东西，在组件当中的某些位置预留空间，当使用者使用组件时可以直接传入组件

  vue 当中的插槽分为具名插槽和不具名插槽，在使用时可以根据需要使用

###### 介绍一下Vue数据双向绑定

+ Vue 是基于MVVM 模型设计的，即数据（Model）与视图（View）通过视图数据层（ViewModel）进行连接与沟通，这也就意味着视图要与视图数据层进行双向的沟通交流，也就是我们所说的数据双向绑定，视图层的展示数据被数据层的数据绑定，同时数据层的数据也会被视图层的数据绑定
+ 当我们修改dom当中的数据（例如input当中的value时），可能会修改data当中的数据，当data当中的数据发生改变时，又可能会导致页面发生更新，也就是我们所说的数据视图双向绑定
  + 视图层绑定数据是很简单的，基于dom的事件直接执行对应的逻辑代码，修改data当中的数据
  + 但是data当中的数据绑定视图层就比较麻烦了，也就是我们所说的响应式原理

###### 什么是MVVM模型

+ mvvm全称是model-view-viewmodel 模型，即数据-视图-视图数据层模型

  + view 即展示页面，即dom
  + model 即数据，一般就是JavaScript数据
  + viewmodel 接受JavaScript（一般来自后端）数据，加以处理之后产生的视图模型层（dom），接受前端的视图更改，向JavaScript数据派发事件（React，vue就是这个模型当中的视图数据层）

  在这个模型当中，视图与数据是不能直接交流的，必须经过视图数据层

  这就是MVVM模型
  
  它使得开发者只关注Model的变化，让MVVM框架去自动更新DOM的状态，从而把开发者从操作DOM的繁琐步骤中解脱出来！ 

###### Dom异步更新与nexttick()函数

+ 当vue当中的数据发生改变的时候，组件会重新渲染，dom会更新，但是这种更新是异步的，因为dom 的操作是十分消耗性能的，如果数据一发生改变就立即刷新，那么无疑是性能极低的，所以vue 使用异步更新dom的方案，当数据更改时，不立即更新dom，而是等待下一次渲染的时候再更新dom，但是这也会导致一些问题，当我们在修改dom之后直接获取dom是获取不到的
+ 而nexttick函数就是在下一次dom更新之后会调用的回调函数

###### ref 的返回值是什么，ref可以重复吗

+ 在vue中直接输出$refs 当中的某个绑定组件的ref会返回一个对象，对象包含组件信息，例如methods与data，我们也可以通过ref 直接获取到组件当中的方法并使用
+ ref绑定一个非组件dom 元素的情况下则是返回指定的dom元素
+ ref不能重复，当出现多个元素或者组件绑定到同一个ref上的情况，使用该ref只能访问到最后一个绑定该ref的元素或组件

###### ref的使用

+ 绑定：将我们需要访问到的组件或元素绑定ref属性值，当为其绑定上该属性值之后，他们就会被添加到Vue实例当中的$refs 属性当中

+ 获取：我们可以直接通过Vue实例.$refs.name 的方式获取到某个元素或组件，绑定一个组件时返回的是一个包含组件信息的对象，绑定元素时返回的是dom元素

+ 注意：
  + ref属性是在渲染完成之后才挂载到元素与组件上的，这也就意味着，我们只能在mount 周期之后才能通过ref访问到我们想要的元素与组件
  + 当我们为一个使用v-for的元素绑定的ref的情况下，ref的返回值会是包含这些dom的数组

###### VUE2.0双向数据绑定的缺陷

​		Vue2.0的双向数据绑定无法对数组直接修改的数据进行绑定，只能对数组的几个原型方法进行的数据修改进行监听

​		并不是不能实现对直接修改数组的数据进行绑定，只是那样会消耗大量的性能，得不偿失

###### 讲讲vue虚拟dom与diff算法

​	虚拟dom的本质是记录了dom节点信息的对象，对象内部保存了一个dom节点的所有信息（例如节点内部的文字，节点的子节点信息，节点的属性信息等），它的出现是为了在不操作dom 的前提下，比较两个dom的区别，便于dom的更新。

​	比较虚拟dom 的区别并进行更新的算法即是diff 算法。vue的diff算法是平级比较的，即在新旧dom当中，只会对层级相同的节点进行比较，例如dom的子节点就只会与dom的子节点进行比较，而不会与dom子节点的子节点进行比较，更不会对dom进行比较。

+ diff算法对比当前虚拟对象与原本位置的虚拟对象是否是同一个对象，通过该虚拟dom 的标签类型与key属性值进行判断（即处在同一层级的虚拟dom，只要他们的标签类型与key 属性的值相同，他们就会被当做是同一个元素），这也是为什么创建相邻的重复节点时，我们要为其携带上key属性。
  + 对相同的元素，我们不需要对元素本身进行过多的操作，我们只需要比较两个元素的内部（即innerHTML与子元素）是否相同。本质上就是，当前层级的元素相同，递归的对下一层级进行比较。
    + 比较innerHTML是比较简单的，直接对比修改即可
    + 比较子元素，由于一个节点可能有多个子节点，可能节点乱序，为了尽可能减少dom的删除与插入操作，尽可能使用原本创建好的dom节点，因此使用了多指针算法，使用新前旧前新后旧后四个指针不断的将相同的节点排出待对比区间。如果多指针算法对比结束，新旧虚拟dom都还存在多个未对比节点，则会进行遍历对比，直到新前新后或旧前旧后节点重合，则表明现在只需要删除或添加节点。
  + 对于不同的元素，则是直接将其暴力删除，并直接重建，不会再去比较其内部节点是否相同

## React

###### React生命周期

+ react 的生命周期主要分为三个大阶段：挂载，更新，销毁

  每个阶段各自调用了不同的生命周期函数

  + 组件创建
    + constructor  组件初始化，例如数据初始化，此时无法访问到dom元素
    + render  组件渲染
    +  componentDidMount   组件挂载完成
  + 组件更新
    + render  组件渲染
    +  componentDidUpdate   组件更新完成
  + 组件销毁（卸载）
    +  componentWillUnmount   组件卸载完成

###### hook函数组件与class类组件的区别

​	hook是react新推出的特性，本质上，hook完成的事情只有一件，在保留函数式组件的优点的同时，使其获取到了一些class的特性，例如state。在保留了函数式组件简单易用的优点的前提之下，为其携带上了类组件的优势（生命周期、state、在组件更新时不用像函数式组件一样需要重新执行所有代码）

​	函数式组件原本的缺陷

+ 没有自己的状态，由于每次组件更新都要重新执行函数，因此函数式组件内部保存状态是没有意义的，每次都会被更新。因此只能通过props从父组件当中获取到数据

+ 无法监听生命周期

  class组件原本的缺陷

+ 复杂的生命周期函数（API变动巨大）

+ 复杂的使用（this指向问题）

+ 难以拆分，代码阅读困难（在一个类组件当中，总是会混杂大量的不同的逻辑，这会使其难以拆分，难以阅读）

再回到这个问题，hook与class的区别是什么？（我们这里的hook是指代使用hook的函数式组件）

hook本事是函数式组件，而class本质是类，他们最大的区别在于class的缺点已经被hook解决了，即复杂的生命周期函数，组件难以进行功能拆分，麻烦的this指向问题

###### React单向数据流传递是什么意思？

​	首先，react作为数据视图层的框架，是由数据驱动视图，而这种驱动又是以组件为单位的，因此我们常说的数据，其实指的是组件状态，即state。

​	而数据流则是这些组件之间的组件状态（数据）的传递。

​	单向数据流：顾名思义，数据的传递是单向的，具体来说，某个节点的数据改变之后，只会影响到它下（后代）组件，而不会影响到它上面（祖先）组件，数据流的流动总是从上至下的。

​	单向数据流为程序员带来的要求：在react当中，子组件无法操作父组件的状态，且来自父组件的props是不可更改的。

​	为什么要求要单向：如果数据流动是双向的（），那么组件的数据改变影响到父组件，父组件的所有子组件都要更新，依次类推，那将会是性能地狱。

需要注意,Vue也是单向数据流传递

###### React当中的防抖与节流

​	react当中是无法使用常规的防抖节流的，以防抖为例，防抖的核心就是在下一次执行操作时将上一次执行操作定义的定时器timer清除，而逻辑代码是在timer内部的，因此timer的清除是防抖的核心。而在函数式组件更新的时候，是会重新执行整个函数的，会在新的执行上下文当中创建新的timer，此时我们再尝试清除timer，清除的就已经不再是以前的timer了，因此防抖会失效。

+ 使用useRef，绑定唯一的timer与flag，使其不更新
+ 使用useCallback

###### hook？

​	hook是react新推出的一系列api，本质上是一个个的函数，我们可以在函数式组件当中使用hook来完成一些函数式组件原本完成不了的事情。例如调用生命周期函数（useEffect），例如进行组件的状态管理（useState）。

​	需要注意的是，hook理论上是不能在函数当中使用的，但是如果我们需要进行一些与hook相关的逻辑代码的抽离，我们可以使用自定义hook：在我们创建一个函数的时候

###### setState的合并策略

​	setState的调用会在后台直接调用render函数刷新页面。如果连续多次调用setState，显然会对性能带来很大的影响。

​	因此react会先通过一个函数（React的内部函数）判断当前setState是否需要进行合并更新（默认是不需要），如果需要则将setState通过迭代器的方式存储到一个队列当中，再在同步代码执行完毕之后异步执行队列当中的setState，异步队列当中的setState就是被合并的。如果不需要合并更新，则直接同步更新。

​	这是一方面的合并	

​	同时，多个setSate的操作还会被合并。连续多次使用对象方式修改state，会最终只会有一个生效。

​	这是因为在setSate调用时，react会将当前的state值赋值给preValue这样一个变量，使用对象方式修改，每次都是在preValue的基础上进行修改，生成Value，注意每次都是这样，这也就意味着，最终输出的Value是preValue最后一次修改得到的结果，这是另外一方面的合并策略

​	需要注意的是，函数式修改state，每次都会修改preValue，因此修改state的操作不会被合并。但是它会被batchedUpdates 函数操作，可能会变成异步代码。

###### setState是同步还是异步

​	先说结论：setState本身是同步的，但是React的一些函数有时候会将其作为异步代码执行。

​	上面提到了React存在合并策略这样一个setState的执行方式策略。

​	如果react底层 batchedUpdates 函数认为需要合并，那么他就会被放到异步队列当中，等到同步代码执行完毕才执行，那么它就是异步执行的，如果这个函数认为它不需要进行合并，可以直接执行，那么它就是同步的。

​	我们注意到，整个过程，setState是否是异步都是由React底层决定的，如果我们绕过React，或者说绕过batchedUpdates 函数，那么setState就会默认同步执行，这也就是为什么，setTimeout当中setState总是同步的，因为它根本被放到了下一个宏任务当中，不受react或者说batchedUpdates 影响。

# HTML与CSS

######  html5新特性 

######  css有什么布局方式 

######  如何清除元素浮动 

+ 什么是元素浮动
  + 我们知道浮动元素是不在标准流当中的，因此它是无法撑起父元素的高度的，所以可能会出现某个父元素内部的子元素全是浮动元素，那么此时父元素就会出现高度塌陷，即失去高度，这是一个具体的案例，实际是这种浮动影响到其他页面的布局的情况我们称之为元素浮动
+ 清除浮动
  + 通过伪类:after与:before在浮动元素前后添加块元素，使两个块元素撑起高度
  + 为元素添加clear 属性也可以直接清除浮动

###### 事件冒泡与事件捕获

+ 当我们触发一个元素的事件，例如点击时，本质上不仅点击了元素本身，还对元素的父元素也触发了同样的事件，当然也包括父元素的父元素。。。。依次类推，这便是我们所说的事件的冒泡，当我们触发一个元素的事件时，该事件会向上传递，直至到达根元素，这便是事件的冒泡
+ 当我们触发一个事件的时候，是由外部元素先接受到事件，处理，再传递给内部元素，即外部元素会先触发该事件，内部元素后触发，事件触发的方向与事件的冒泡相反，这就是事件的捕获，本质上也是一种事件传递的方式，不同之处在于事件传递的方向两者是相反的

###### em与rem

+ em是根据父组件的默认字体大小，按照比例获取px数，例如父组件默认字体大小为16px，1em就是16px，但是由于其只由父组件决定，所以可能出现一些问题
+ rem是根据body的默认字体大小，按照比例获取px数，比起em更加标准化，只要body的默认字体大小为16px，那么在任何位置使用rem，1rem 的值都是16px



# JavaScript

###### for of能遍历对象吗

​	不能，for of只能遍历内置了迭代器接口的数据结构，而JavaScript当中的对象是不具备这个接口的

###### for in 能遍历对象吗

​	可以，它可以遍历对象的keys

​	for in 遍历数组的话，虽然一定会遍历所有的数组，但是可能会乱序，所以一班不用于数组的遍历

######  var let const的区别 

​	let与const是一对，他们的性质大致相同，不同之处在于const定义的是常量，是无法修改的，而let定义的是可修改的

​	letconst与var 的不同：

+ var定义的变量会放入到VO当中，作为VO的属性
+ var没有块级作用域而let有
+ var存在变量提升，而let没有
+ let存在暂时死区，即在声明之前无法使用（没有变量提升）

######  js作用域介绍一下 

+ 作用域就是变量可以生效的范围，例如我们在一个函数作用域中定义的变量，就是无法被外部访问到的，作用域内部的作用域也是属于当前作用域的，因此可以访问当前作用域当中的变量

  以函数执行为例，当我们执行一个函数的时候，会为其创建一个函数执行上下文放入到执行上下文栈当中，而该执行上下文对象当中的VO就会指向它的父级作用域，而父级作用域也会有同样的属性指向父级作用域的父级作用域，直至指向全局对象也就是GO，这种指向关系形成了一个链条，也就是我们所说的作用域链

###### js的作用域链机制

首先作用域链分为了静态作用域和动态作用域链两种

+ 静态作用域链，作用域在声明阶段就已经确定，由函数声明的位置确定，由于由函数声明确定，因此可以通过静态词法分析直接得出，因此也被称之为词法作用域
+ 动态作用域链，作用域在函数调用时才确定，由函数的调用关系确定

js是属于静态作用域链，即在声明时就确定了作用域

**注意：不要混淆了执行上下文与作用域，执行上下文是代码执行的环境，它内部保存了父级作用域的指针，但是两者不是一个东西，执行上下文关联的vo，和作用域之间倒是感觉有点暧昧**

**注意：静态作用域链与动态作用域链是作用域链的向上访问机制，在这个机制之下，js存在函数作用域全局作用域与块级作用域，两者之间不冲突，只是在确定当前作用域的上级作用域时，需要知道js是级静态作用域链，由声明决定上级作用域**

**注意：js当中的this 的访问规则与动态作用域链十分相似，但是不能说this是动态作用域链！！！**

#### 作用域与作用域的原理

#### vo与ve的关系

#### 词法环境与变量环境的关系

#### 词法环境、变量环境与执行上下文的关系

######  js有几种继承方式 

+ js的继承主要分成了两个部分，成员方法的继承与成员变量的继承
  + 成员变量的继承主要是通过在子构造方法当中直接调用父类构造方法的方式，在子类当中通过父类构造方法调用call方法，就可以在子类对象中生成对应的父类数据，而父类方法的继承则是通过原型链，有很多中实现方式，例如直接使子类对象的proto指向父类的原型对象，使子对象的proto指向父类的对象，但是这些方法都是殊途同归的，但是这些方法都或多或少存在一定的缺陷，比较完善的方法是创建一个原型对象指向父类构造方法的原型对象的对象，并使该对象成为子类方法的原型对象，以此完成对成员方法的继承，然后借助call 进行变量成员的继承，继承方式的区别其实就是成员方法继承的方式的区别

######  es6新特性 

+ 说到es6 的新特性，就必须提到es5 的缺陷，我个人认为最主要的缺陷在于
  + 没有实现模块化
  + 变量定义关键字（var）没有块级作用域
  + 没有类的概念（主没有实现继承，es5也没有类方法，es5是通过原型链勉强实现这两个功能）
  + js单线程无法正确处理一些异步代码
+ 这些问题es5 当中是存在一些非官方的解决方案的，例如模块化（cjs），块级作用域（闭包），类（原型链），单线程（回调），但是依然是缺乏一个官方的解决方案的
  + 模块化 ESmoudule，舍弃了原本cjs的直接将需要导出的数据放入moudule对象导出，转而在开辟单独的内存（环境变量记录），专门用于记录导出的数据，在内存当中使用const 的方式保存数据，在模块当中导入数据，则是直接将内存当中的变量导出，由于其是const 方式进行的存储，所以使用数据的模块当中是无法修改数据的，然后对数据进行数据劫持，当模块当中的数据改变时，使用数据的模块使用的数据也会跟着修改
  + let const 解决块级作用域问题
  + class extends 解决
  + promise 的出现，使用一种全新的思路实现了js 的异步

######  es6怎么去重，es5怎么去重，es6除了set怎么去重 

- es5的去重与es6除去set的去重其实差不多

  - 使用indexOf  方法，indexOf方法接受一个数据作为参数，通过一个数组调用该方法传入一个数据，它会返回该数据在数组当中的位置，如果数组中没有该数据则返回-1，基于该原理

    - 设置一个返回数组，遍历原数组，每次遍历一个数据都通过indexOf 判断返回数组当中是否存在该数组，如果存在就不加入返回数组

    ```JavaScript
    function bar(arr){
        let res = []
        for(let item of arr){
            if(res.indexOf(item) === -1){
                res.push(item)
            }
        }
        return res
    }
    ```

    - 遍历整个数组，对每个数据都调用indexOf 方法，如果方法返回的位置与当前的位置不符，说明当前的数据是重复的，删除当前数据，节省空间，但是可能会花费更多时间

    ```javascript
    function bar(arr){
        return Array.prototype.filter.call(arr, function(item, index){
            return arr.indexOf(item) === index;
        });
    }
    ```

  

- es6 的去重主要是通过set 数据结构的数据不可重复性

  ```javascript
  function bar(arr){
      return [...new Set(arr)]
  }		
  ```

######  什么是深拷贝和浅拷贝 

+ js 中，我们为一个变量赋值为引用类型数据时，本质上是将该引用类型数据的引用（地址）赋值给了变量，因此，当我们直接拷贝一个引用类型数据时，本质上是对引用的拷贝，因此，两个变量会指向堆内存当中的同一个地址，这种拷贝就是所谓的浅拷贝
+ 与之相对的，深拷贝就是拷贝一个引用类型数据时，直接在堆内存当中开辟另外一块空间，创建另外一个引用类型数据，然后赋值给原本的数据，这便是深拷贝

######  js有什么方法是深拷贝或浅拷贝 

+ 例如splice（深拷贝）与slice（浅拷贝）方法

######  讲下js的原型对象 

+ 在js 当中， 每一个函数都有自己的prototype  属性，指向它的原型对象，我们称之为显示原型对象，而当一个构造函数创建一个对象时，会为其携带上  proto  属性，该属性会指向其构造方法的显示原型对象，这便是对象的隐式原型对象，我们称之为隐式原型，而由于方法的隐式原型对象也是对象，所以原型对象也是存在自己的原型对象。。。。。。这便产生了一条由原型构成的链条，即原型链

######  讲下闭包 

+ 我们平常习惯说的闭包是由一个外部函数和一个内部函数构成，通过对内部函数的使用，保留内部函数，再在内部函数当中通过强引用指向外部函数当中的数据，使得外部函数当中的数据不会被垃圾回收机制回收，但是在官方定义当中，只要一个函数使用了非当前函数作用域当中的数据，都称之为闭包

######  介绍下箭头函数，箭头函数的this可以用callapply改变吗 

+ 箭头函数是es6 推出的一个新的函数形式，它最大的特点就是简单的声明，以及不同其他函数的this指向，箭头函数的this永远会指向它声明处的作用域当中的this，本质上是因为箭头函数没有自己的this，当我们在箭头函数当中访问this时，就会直接顺着作用域链向上访问，直到访问到某个作用域中存在this为止，在很多es6 新特性中都使用到了该性质，例如promise的then 方法的实现 
+ 注意箭头函数是存在自己的作用域的，只是它的函数执行上下文对象的父作用域永远指向声明处的父作用域（还需要注意，箭头函数是不承认块级作用域的，因此寻找其作用域就是寻找其声明处的函数声明），只是没有自己的this而已
+ 不可以，箭头函数调用apply call 函数时，传入的第一个参数会被忽略

######  call/apply/bind这三个方法怎么使用 

+ call 与 apply 的功能与使用是比较相似的，都是通过一个函数对象调用方法，然后将我们需要更改的this 作为第一个参数传入，然后将其他参数紧跟其后，唯一的不同在于apply 接受一个数组作为调用原函数的参数，而call 则是直接接受多个参数作为调用原函数的参数
+ bind 不同于前面的函数，它本质是一个高阶函数（和react 当中高阶组件的性质相同），它对函数进行加工，然后返回处理过后的函数，我们使用方法对象调用bind 方法的时候，会返回一个this 被修改的处理完成的函数

######  bind要传递参数怎么传 

+ bind 的第一个参数传入需要绑定的this，后续参数则会依次作为函数的实参传入函数当中，后续调用bind函数返回的函数时，其this会变成我们通过bind 指定的this，而其他参数也会受到bind 中的后续参数的影响

###### 修改形参会影响实参吗

+ 依据情况，形参是对实参的浅拷贝，在栈内存当中是不同的位置，而对于引用数据类型数据而言，栈内存中存放的是引用，对形参的修改最终都会修改堆内存当中的对象实例，所以引用类型数据修改形参会影响实参，而基本数据类型则不会

###### 如何判断变量是否是数组类型？ 

+ Array.isArray() 方法
+ instanceof 关键字，该关键字是基于原型链进行查找，可以判断数组类型数据
+ toString()方法，tostring方法存在于初始object对象当中，但是在很多不同的对象当中对它有着不同的实现，也就导致使用不同的数据类型调用该方法，返回值也是各不相同的

###### XML，JSON的异同？ 

+ xml是一种用于传输与储存数据的标记语言，xml文件后缀为.xml，是纯文本形式
+ json是一种数据交换格式，本质是字符串，通过json可以将各种类型的数据转化为字符串再进行传输，各种语言的数据都可以通过json转换为相同的结构，这也就因为这可以通过json实现跨语言的数据传输
+ 相同点：
  + 两者都用于数据传输，都可以进行跨平台跨语言的数据传输
+ 不同点:
  + 传输相同的数据，json所需的字符更少
  + xml的层次结构比json更清晰
  + 也就是说两者各有优点，json的优点是使用的字符少，xml的优点是层次结构更加清晰

###### 闭包的内存泄露？如何解决？

+ 内存泄露是指某些无用内存由于一些原因无法被回收，导致其一直占用内存，无法被释放，而每个闭包都会在内存中开辟一个新的空间用于保存数据，所以闭包过程中很容易产生内存泄露的问题
+ 解决方案

  + 将无需使用的变量在闭包中清除（赋值为null）
  + 避免循环闭包的循环引用 
  

###### 什么是模块化

​	模块化是一种开发模式，它要求将整个程序分割成为一个个小的结构，每个结构有着自己的逻辑，用于实现特定的功能，同时有着自己的作用域，不会影响到其他模块，将这些模块希望能将自己的变量，函数，对象导出给其他的模块使用，同时也希望可以使用其他模块的变量，函数，对象

+ 将一个程序划分为多个模块，每个模块有着自己的逻辑与功能
+ 每个模块有着自己的作用域，不会干扰到其他模块（模块与模块不会相互干扰）
+ 每个模块暴露自己的函数，变量与对象给其他模块使用
+ 每个模块也都可以使用来自其他模块的变量，函数与对象

###### JavaScript当中的模块化

​	首先需要知道的是，不论什么方式的模块化，当我们导入一个模块时，都会执行该模块内部的代码，只有在执行代码之后，我们才能获取到需要的导出数据，但是由于模块的独立性（或者叫做模块之间的互不干扰性）我们在任何位置使用一个模块的导出数据的时候，使用的都是相同的数据，这也就意味着，多次导入同一个模块的时候，我们并不需要多次执行代码，只需要使用第一次导入模块时的代码执行结果即可（我们执行代码的目的是获取模块的执行结果，以取得需要的导出值，而这个导出值是不变的，因此我们无需多次导入）

​	其次js 当中的模块与模块之间的关系是类似于图结构的，而对这些依赖关系的处理本质上就是对图结构的遍历，而js模块当中的遍历方式是深度优先（DFS）

+ commonJS

  ​	将需要的数据放入当前模块的module.exports 对象当中（注意是一个对象），在其他模块当中使用require函数导入模块时，require 函数会直接将目标模块的module.exports 对象作为返回值返回，我们使用一个变量接受该对象便可直接使用，由于module.exports本质上是一个对象，是单独存在于堆内存当中的，所以它的一些特殊性质也是可以预见的

  + 需要注意的是，cmj规范要求一个模块当中直接存在一个exports 对象，node为了满足这个规范，所以也在全局对象当中添加了exports 变量，它的本质就是module.exports 的别名，直接指向module.exports即在模块开头

    ```javascript
    module.exports = {}
    exports = module.exports
    ```

  + 说到cmj 就一定要提到module 对象，该对象是node当中的伪全局对象，它主要作用就是保存了一些模块化相关的数据，例如

    + loaded：该对象用于表明当前模块内部代码是否执行过，当我们使用require 函数导入一个模块时，会先判断该属性的值，以确定当前模块是否执行过，如果执行过，直接使用module.exports 的值即可，否则需要执行当前模块当中的代码，这也是防止同一模块重复执行的重要属性
    + chilren：保存了当前模块的子模块的信息

+ ES Module

  ES Module的使用主要在于两个接口 export 与 import ，这是两个es6新增的关键字

  + 导出（export）

    + 我们可以直接将需要导出的数据放到export 关键字之后，会将其直接导出

      ```javascript
      let name = 'tkoyist'
      export name
      ```

    + 我们也可以在export 关键字之后添加大括号，将我们需要导出的多个数据都放入大括号之中，这些数据就都会被导出

      ```javascript
      let name = 'tkoyist'
      let age = 18
      let sayHello = function(name){
      	console.log('hello '+ name)
      }
      export{
      	name,
          age,
          sayHello
      }
      ```

      + 注意：这并不是将导出的数据放入了一个对象当中进行了导出，这只是一个特殊语法，将大括号内部的数据导出，注意将其与cmj 的作为对象导出区分开

  + 导入（import）

    + 我们可以直接使用import关键字将需要导入的数据从特定文件当中导入，使用from关键字指定模块位置

      ```javascript
      import name from'./myModule'
      // 便可直接使用name 变量了
      ```

    + 我们也可以在import 关键字之后添加上大括号，一次性从一个文件当中导入多个数据以供使用

      ```javascript
      import {name,age,sayHello} from'./myModule'
      ```

    import 关键字的导入是在解析时进行的，即在代码解析阶段就找到了对应的依赖模块，并对其进行的导入（异步导入，找到模块之后，交由其他线程进行代码的执行），这也就意味着在代码执行完毕之前，模块间的依赖关系就已经被理清了，因此我们不能在逻辑代码之中使用import关键字，否则js引擎会搞不清楚依赖关系

    + import() 函数导入

      + import()函数的出现就是用于解决import 关键字无法在逻辑语句中使用的问题的，它的本质既然是一个函数，那么它的执行理所当然是在解析完成之后，所以是不会产生上面提到的问题的，即使是在逻辑语句中也是可以正常使用的

###### commonJS与ES Module的区别

+ cmj导出的数据是以对象的形式保存在外部，我们对其导出数据的使用也是以对象的方式进行的，即对对象属性的访问，而esm则是开辟的一个 单独的空间（模块环境记录）用于保存导出的数据，在模块环境记录当中，是以常量（const） 的形式对数据进行了保存

  ```js
  //当我们使用esm导出数据时
  let name = 'tkoyist'
  let age = 18
  export{
   name,
   age
  }
  //此时模块环境记录当中会以常量形式保存（这也就意味是保存在栈内存当中，而非堆内存当中）
  const name = name
  const age = age
  //我们在其他模块当中使用的数据就是此处定义的常量，因此是无法被外部模块更改
  //同时在模块环境记录当中的数据是响应式的，当模块内部数据发生改变时，会销毁原本的常量，重新生成一个新的同名常量
  ```

  需要注意的是，cmj当中将数据放入对象当中，本质上放入的是对原本数据的拷贝，因此对外部数据的改变，不会导致导出数据的改变

  ```js
  let name = 'tkoyist'
  module.exports={
      name:name
  }
  name = 'aaaaa'
  //此时在外部打印 name ，依然是'tkoyist'，因为在exports中拷贝数据之后，原数据与导出数据之间已经没有直接联系了
  ```

  而在esm当中，我们提到了模块环境记录当中的数据是响应式的，因此

  ```js
  let name = 'tkoyist'
  export{
    name
  }
  name = 'aaaaa'
  //理论上外部使用的值将会是aaaa
  //经测试，却是如此
  ```

+ cmj的模块导入是在代码执行阶段，而esm的模块导入是代码解析阶段

  cmj是运行时加载，而esm是解析时加载

+ cmj的模块导入是同步的，而esm是异步的

  + 在代码执行阶段，当cmj当中读取到模块导入语句时，会直接去寻找到对应的模块代码，在主线程当中执行模块代码并获取所需数据，完成模块的导入

  + 在esm中，在代码解析阶段（parsing），解析器解析到import语句时便会直接将模块代码交由其他线程异步执行，以异步的方式获取到数据，我们姑且将其理解为回调，而import 函数的执行是在代码表层的，它的数据处理更加露骨，import函数会直接返回一个promise实例，我们可以直接通过then方法对该异步将结果进行处理

    需要注意的是，import()函数与import语句的导入都是异步的，但是import语句并没有返回一个promise实例，而是直接在内部完成了异步数据的处理，import函数之所以不在内部直接进行处理，因为其存在于代码表层

###### null与undefined的区别

+ null表示一个值已经被定义了，但是值为空，会占用内存空间
+ undefined表示一个值定义了，但是没有赋值

###### this指向问题

+ new调用函数，this指向新创建的对象
+ call、apply、bind当中的this指向预设的对象
+ 严格模式下，执行上下文的this指向undefined，非严格模式下指向执行上下文对象（全局执行上下文对象与函数执行上下文对象）
+ 使用对象.的方式调用对象内部的方法，this指向该对象

###### 讲讲变量提升

+ 在js当中，创建一个新的执行上下文时，会在代码执行之前先解析作用域当中的代码，解析到变量声明的代码时，会直接将其执行，将变量挂载到当前的执行上下文对象当中，但是不会赋值，Function fun 的方式声明函数，会拥有比普通变量更高的优先级。

###### new关键字调用函数之后发生了什么

+ 在堆内存中开辟空间，创建一个新的对象

+ 为对象的__proto__属性赋值为当前函数的prototype属性

+ 将函数的this赋值为当前对象，执行函数

+ 如果返回值为null，则返回之前创建的对象，否则返回返回值

  在底层：进入函数之后，执行上下文栈中会新添加一个执行上下文，上下文的AO会指向一个新创建的对象，然后在执行上下文当中执行代码。

###### 为元素添加事件监听

​	在JavaScript当中，我们可以使用函数 addEventListener 为一个dom元素添加事件监听，该函数接受三个参数，

第一个参数是需要监听的事件的类型

第二个参数是事件响应函数

第三个参数是选择当前事件触发机制，传入一个boolean，  为true时捕获，false时冒泡。 

# 数据结构

###### 数组与链表的区别？

+ 数组中的数据，内存地址是连续的。
  + 因此在后续插入数据的时候，在中间位置插入数据，需要将后面的数据在内存中整体后移（删除数据也是如此）
  + 即使是在末尾插入数据，也可能会出现数据长度大于数组预定长度，需要增加内存
  + 查询数据时，由于内存空间连续，十分易于查询
+ 链表当中的数据，内存地址不连续，数据与数据之间是通过指针进指向的。上一个数据直接指向下一个数据的地址。
  + 链表的插入与删除性能高，不论多长的链表，都无需重新申请内存空间
  + 链表的数据查询很麻烦，只能从头到尾进行查询

综上所述，数组易于查询，但插入删除数据十分困难，而链表易于插入删除数据，但是查询数据十分困难。

# 计算机网络

###### cookie

+ cookie本质上是**浏览器内部**存储的一个极小的文本文件，内部以键值对的方式存储，向同一个域名发送请求会携带上与当前**域名**（这也就意味着一个域名下很可能存在多个cookie）中的对应的所有cookie，需要注意的是，**一个浏览器当中可以有很多个不同的cookie**，每个cookie都是独立存在的，互不干扰。每次cookie传输也只是选中其中的一个cookie。
  + cookie 是明文传输的，存在安全隐患
  + cookie容量只有4kb
  + 由于发送请求都要携带完整的cookie，所以一定会出现携带不需要信息的情况，这就会造成性能浪费
+ cookie的出现是为了弥补http协议无状态的缺陷。在客户端用于保存http状态信息，当一次http请求响应结束之后，再次发送请求携带上cookie可以用于确认连接状态
+ 这也是为什么很多攻击方式针对cookie，因为只要获取了cookie，攻击者在服务端眼中就是用户

###### session

​	这里的session并不是指sessionStorage。

​	session的出现也是为了解决http无状态的问题，不同于cookie，session会将状态信息保存到服务端

​	session当中保存了用户的会话信息。

​	每个session会有对应的sessionID，浏览器现在只需要在cookie当中携带自己的sessionID，服务器便可直接在本地查询到对应的session信息。

###### token

​	为什么需要token：上面的session与cookie基本已经解决了状态的问题，但是现在的服务器早已不是单个服务器的时代了，常常需要一个反向代理服务器代替用户去一个服务器集群当中交互数据。而不同的服务器不会共享session，这也就意味着，一个用户像一个域名发起的请求，可能会转接到不同的服务器，导致用户需要多次登录。这显然是很影响使用体验的。

​	token的本质是一个由服务器生成的全局唯一的字符串

​	当用户向服务器发送请求时，服务器会生成唯一的token。保存在本地的同时，随着响应返回给客户端，用户发送请求时携带上token，服务器便直接去对应的位置找到对应的session。获取到用户的登录信息。

​	一般会被加密，避免被复制

###### 什么是跨域，如何解决跨域问题？

+ 浏览器遵循同源策略，只有两个请求的 协议  主机（host）端口 都相同的情况下，两个协议才被称之为同源协议，针对非同源协议存在一些限制：

  + 不能读取对方的dom
  + 不能访问对方的cookie localStorage indexDB
  + 限制XMLHttpRequest请求（ajax的实现核心）

  在网页中中向与当前URL不同源的URL发送请求时，请求的响应会被浏览器拦截，注意是被浏览器拦截，也就是说它其实是到达了客户端的，只是被浏览器的同源策略限制了

+ 解决跨域问题的方案有：

  + CORS，本质是一个规范，需要浏览器与服务器都支持该规范，才能正常使用

    + CORS将请求分成了两类

      + 简单请求（主要以GET,POST,HEAD为主，当一些请求满足其他要求的情况下也可以被视为简单请求，但是这里不做赘述）

        基于CORS规范，对简单请求的处理，要求客户端发送请求时在请求头中带上origin 字段，指向源端口，满足CORS规范的客户端在接收到包含Origin字段的请求时，会在返回值当中携带Access-Allow-Control-Origin字段，该字段用于记录来自哪些源端口的跨域请求不被拦截（注意，Access-Allow-Control-Origin虽然是由服务器进行维护，但是该字段的使用是在浏览器中，因为是浏览器拦截跨域请求，该字段交给浏览器之后，浏览器会根据字段当中的内容决定是否拦截响应）

      + 非简单请求:除去简单请求之外的请求都称之为非简单请求 

        基于CORS诡诞的非简单请求会先发送一个Option请求作为预检请求，请求中会携带Origin字段，服务器会针对该请求作出响应，响应中会记录当前请求是否满足要求，浏览器接收之后，如果符合要求则会发送真正的CORS请求，之后的处理就和简单请求一致了，而如果不满足请求，则会抛出错误

  + JSONP本质是通过script标签，script标签本身就具有跨域能力

  + 反向代理，通过代理服务器接受来自多个服务器的跨域资源，再转发给客服端，对于浏览器而言，所有数据都来自同一服务器的统一端口，是满足同源策略的。对于代理服务器而言，因为发送请求不再经过浏览器，因此不会出现跨域拦截的问题。

###### 域名与端口的关系

+ 域名与IP地址是对应的，但是这种对应并非一一对应，一个IP地址可以对应多个域名，一个域名也可以对应多个IP地址，主要是用于找到对应的计算机
+ 而端口是针对某个具体的计算机，用于指向指定计算机当中的不同服务，因为一个计算机可以有多个不同的服务，我们找到一个计算机之后，还要找到对应的服务的接口，这便需要通过端口号来指定

以银行柜台为例，域名就相当于银行的地址，我们需要到这个地址办理业务，而端口号则是银行当中的不同柜台，各自处理着不同的业务。

在服务器当中，后端开发会将不同的服务挂载到不同的端口当中，前端会根据需求向不同的端口发送请求，以获取相应的响应，在不同的端口存储着不同的逻辑，当某个端口接受到请求之后，就会根据该端口挂载的服务执行相应的逻辑代码（例如操作数据库，例如返回指定的逻辑）

###### tcp与udp的区别是什么，什么叫面向连接，连接的本质是什么

+ 区别：

  + tcp基于字节流，udp基于数据报

  + tcp面向连接，udp面向无连接

    + t基于tcp的数据传输需要先在通信双方之间建立连接，再根据已建立的连接进行数据传输，传输完成之后也要根据流程关闭连接

  + tcp比udp更加可靠

    + 有状态
      + tcp会监控当前连接的状态
    + 可控制

      + tcp会根据当前的连接情况，自动调整连接（即控制连接）

######  什么是Ajax

​	要说什么是ajax，先要明白ajax干了什么工作，在没有ajax的时候，网页的数据更新是需要重新刷新整个页面的，而ajax的出现就是为了解决这个问题

​	可以将它看做一个标准，它借由XMLHttprequest和异步JavaScript实现

​	axios是对该标准的一个实现

###### AJAX的实现

###### ssl的认证过程和ssl证书的原理

​	ssl即安全加密套接层，即我们常说的https中http与tcp之间的安全接套

+ 认证过程：

  + 客户端发送加密算法列表，客户端随机数RandomA

    + 此处传输RandomA的过程是不加密的，但是不用担心被攻击者劫持，因为服务端返回的一定是带有合法证书的，所以此处也不需要加密

  + 服务端接受到之后返回从算法列表中选出的加密算法，数字证书以及服务端随机数RandomB（由证书携带）和服务器公钥（也由证书携带）

    此处是会使用服务端的私钥加密的，也就是说客户端需要使用公钥进行解密

  + 客户端接受之后先验证数字证书合法性，再提取公钥与随机数RandomB，再产生一个随机数RandomC，经过公钥加密之后传输给服务端

  + 双方使用RandomA，RandomB，RandomC计算生成信息加密公钥secret

  + 双发使用secret作为对称加密的公钥进行后续信息传输

本质上是对称加密与非对称加密的共同使用

###### tcp与udp的区别与使用场景

+ 先说最大的区别，设计思想上的区别，tcp的设计看重可靠性，数据传输的可靠与安全，而udp的设计则是尽可能保证效率。

+ tcp面向连接（在tcp协议进行数据传输之前，会先对当前的通信双方通过三次握手简历连接，传输完毕之后也会挥手断开连接），udp面向无连接

+ tcp可靠性高：有状态，可控制（例如拥塞控制，流量控制，tcp包的顺序控制）

  udp可靠性低

+ tcp报文头长（为了保证其可靠性，需要记录很多数据）

  udp报文头短（效率更高）

+ tcp只支持一对一的数据传输

  udp支持一对多，多对多的传输

使用场景：

​	从上面的区别分析不难看出，tcp更加注重完整性与安全性，尽可能保证连接的可靠性，而牺牲了一些性能（比如较长的报文头，比如流量控制与拥塞控制过程中的性能浪费）而udp则是为了保证传输效率，放弃了可靠性。

​	因此tcp更适合要求通信过程数据完整性与准确性高的场景，例如文件传输，重要状态的更新

​	而udp则更适合通信过程中数据完整性要求低的场景，例如实时通信，游戏数据传输，网络电话，网络视频等

###### get与post的区别

首先get是用于请求资源的请求格式

而post则是对get请求针对安全性进行优化后的产物，两者之间区别的底层原理都是基于此的

+ get的参数放在url当中，而post的参数放在请求体当中
+ get的url长度有限制，而post的url长度无限制（过长的url处理对服务器来说是负担，如果url长度不设限制，可能出现超长url请求攻击）
+ post只接受ascII编码格式，而get对此无限制
+ get在浏览器当中回退与刷新无副作用，而post则需要重新提交数据
+ get请求大多数情况下只会发送出去一个tcp包，而post请求大多数情况下会发送出去两个（有一些浏览器内核只会发出去一个）
+ get参数保存在浏览器历史当中（当然啦，因为参数在url当中），post则不会

需要注意的是，两个请求都是基于tcp协议的，本质上是没有任何区别的，只是一个参数在url中，另外一个参数在请求体当中，上面所有的区别，都是由于http协议对两者提出的规范不同导致的。也就是说本质一样的，但是http将两者区分开了。

# 浏览器与性能

##### 如何提升渲染速度

图片懒加载

cdn加速

​	cdn全称内容分发网络

​	基本原理就是一个服务器当中的资源分布到全球各地的各个cdn节点当中，使得用户可以在尽可能短的距离内请求到我们需要的资源。需要注意的是，这种资源分布不是覆盖式的全部分布，而是会根据实际情况，决定在什么位置的cdn节点存储什么样的资源，这种资源存储也是会根据后续的情况更改的。

精灵图

​	将需要使用的多个小图整合成为一个大图，减少向服务器请求，获取资源的次数

压缩

​	将需要传输的数据压缩，减少数据传输事件



# 算法

###### 给定两个日期，返回两个日期间隔的天数

+ 思路，获取到两个日期之后，分别获取到它们的时间戳，再计算两者时间戳的差值，通过两者相差的毫秒数，除去 1000 * 3600 * 24（一秒的毫秒数 * 一个小时的秒数 *  一天的小时数）就能求出两者之间相差的天数了，求相差的小时数也是同样的思路

  + 使用Date.parse() 方法计算时间戳，该方法接受一个Date对象，返回时间戳
  + date.getTime()使用一个Date对象调用该方法，直接返回时间戳

  ```JavaScript
  function foo(time1,time2){
    time1 = new Date(time1).getTime()
    time2 = new Date(time2).getTime()
    // 计算时间戳差值  
    let passTime = time2 - time1
    
    let res = []
    // 通过时间戳差值计算天数，小时数和分钟数的差值
    res.push(passTime/(1000 * 3600 * 24))
    let leave1 = passTime%(1000 * 3600 * 24)
    res.push(leave1/(3600 * 1000))
    let leave2 = leave1 % (3600 * 1000)
    res.push(leave2 / (1000 * 60))
      
    return res[0]+'天'+res[1]+'时'+res[2]+'分'
  }
  ```



###### 找出数组当中的重复数

+ 其实很简单，一次遍历就可以解决，问题在于要保证输出的结果当中没有重复项，可以使用set

  ```JavaScript
  function foo(arr){
      let res = new Set()
      let index = new Set()
      
      arr.forEach(item=>{
          if(index.has(item)){
              res.add(item)
          }else{
              index.add(item)
          }
      })
      return [...res]
  }	
  ```


# 八股代码题

###### 1

​	 ![img](https://uploadfiles.nowcoder.com/images/20220316/726901786_1647395297706/D0B7B29BD2E53168EBABDBF69D7D2AC1) 

​	这里的dbl输出20，因为我们通过（对线.对象方法的方式）调用对象当中的对象方法的情况下，对象方法当中的this是指向当前的对象的，同样的，我们在对象方法当中想要访问到对象当中的所有数据，都要通过this进行，类当中定义的方法也一样，需要通过this访问到当前的对象，再访问对象当中我们需要的数据

###### 2

```JavaScript
const name = "1111";
function test() {
    console.log(this.name);
}
let obj = {
    name: '2222',
    people: () => {
        console.log(this.name);
        text();
    }
}
obj.people();
```

+ 打印

   undefined

​		undefined

+ 这里我们使用obj对象调用其内部方法，因此在该方法内部中的this会指向obj对象，但是由于people方法是一个箭头函数，其作用域是固定的，也就是其声明处的作用域，它在对象当中声明，对象是不存在作用域的，因此，对于people方法而言，其作用域就是全局作用域，this指向的就是window

  因此打印this.name 本质上就是打印window.name，这里又出现一个问题，我们使用const name 的方式声明了变量name，很容易让人认为window.name 就是 1111 ，但是注意使用let 与const是不会像var关键字一样在当前执行上下文对象当中添加该属性的，所以打印this.name输出的值会是undefined

  而在people方法当中调用text函数，执行函数输出this.name，本质也是输出window.name，因此返回值依然为undefined

  这里的考察点就是对象方法的作用域，与对象当中的箭头函数的作用域以及const let 与 var 的区别

###### 3

使得这段代码输出为1 2 3 

```
var data = [];

for(var i = 0; i < 3; i++){
    data[i] = function(){
        console.log(i);
    };
}

data[0]();
data[1]();
data[2]();
```

思路：使用闭包保存var当中的数据，使用立即执行函数创建闭包。

```
var data = [];

for(var i = 0; i < 3; i++){
    data[i] = function(i){
        return function(){
        	console.log(i)
        }
    }(i)
}

data[0]();
data[1]();
data[2]();
```

###### 4

输出为?

```
function wait(time) {
    //todo
    return new Promise(resolve => {
        console.log(2)
        resolve();
    })
}
wait(1000).then(() => console.log(3));
console.log(1)
//2
//1
//3
```

​	容易出错的点在于，第一眼看到Promise 内部打印2，下意识就认为这是异步代码。但是不是的，我们在创建promise时传入的回调当中的代码其实本质是同步代码。只是我们常常在内部执行异步任务

# Webpack

###### webpack做了哪些优化

主要分为两个部分

+ 打包速度的优化，例如
  + 做了一些基于语法层面的优化，例如将更消耗性能的forEach转化为for of，使用Set与Map替代Object
  + 例如对完全用不到的包不进行解析，而是直接放入到boundle.js当中
  + 面对较大项目的时候开启多线程打包
+ 压缩文件体积的优化，例如
  + 代码的压缩
  + 提取出一些公共资源，减少重复打包
  + 作用域提升：我们通常为了保存数据或者避免污染作用域会在js代码当中创建大量的闭包，webpack会将这些闭包以合理的顺序合并到一个函数作用域当中，并且修改他们的变量名避免变量名的污染
  + 在模块打包时会将那些引用了但是没有使用到的模块标记，在压缩时将其从bonudle.js当中除去

# Nodejs

###### nodejs到底是什么

+ 是一个基于v8引擎的脱离浏览器存在的JavaScript代码运行环境，通过它我们可以在浏览器之外运行JavaScript代码，也就意味着我们可以像使用其他任何高级语言一样在很多位置运行JavaScript代码

# git

###### 理论问题解答

​	git 是一个分布式版本控制工具，与之对应的就是svn是一个集中式版本控制工具，他们的不同之处在于git会在每一个开发者处保存当前项目的版本信息，而svn则是将项目集中保存在服务器当中

 ![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/26/16615b30ebb2eec5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp) 

 **Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库** 

+ 被git管理的本地项目文件夹被分为了两个部分，一个是保存了项目本地的各种信息以及暂存区（stage与index）和本地仓库Repository以及当前项目的版本信息等信息的隐藏文件.git，其他区域则均为工作区，我们在工作区对项目进行修改之后，需要在讲工作区当中的文件增加到暂存区，再将暂存区当中的文件一次性提交到当前分支当中。

+ 除了本地仓库，项目的所有文件都保存在远程仓库当中，以github提供的远程仓库为例，本地仓库与远程仓库常常使用SSH进行数据交流

  在github当中，我们常新建一个仓库，在此过程中，我们可以使用预定的方式，在本地使用git连接仓库，然后使用指令将本地指定仓库的数据直接提交到远程仓库当中





###### 基本命令

+ 工作区与暂存区的区别：

  首先工作区与暂存区都是保存在当前主机当中的，比较明显的区别就是，工作区是可见的，是我们直接操作的区域，而暂存区是保存在当前项目文件的.git文件夹之下的，其被设置为了隐藏，不能被我们直接进行操作.

  一个被git操作的本地项目文件被分成了两个部分：

  + .git 文件夹
  + 工作区

  即.git文件夹之外都属于工作区，而.git文件夹中当中不仅包含了暂存区stage，还包含了版本库 Repository ，配置与自动创建的分支及其分支头等数据与信息

  **我们前面说过使用Git提交文件到版本库有两步：**

  **第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。**

  **第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。**上面

+ 使用git的时候，需要为当前用户（主机设置表示，即用户名与邮箱）

+ mkdir 用于创建文件夹
+ git init 会将当前文件夹初始化为git可以管理的仓库
+ git add 文件名 将当前工作区指定文件当中的修改增加到暂存区stage
+ git commit 将当前暂存区当中的文件一次性提交到当前分支当中
+ git push 将当前分支当中的文件一次性上传到远程仓库当中
+ git reset 版本回退，结合多个属性可以实现指定版本的回退
+ git checkout --文件名 将指定文件在工作区所做的修改撤销（--不能省略）
+ git clone 远程仓库域名 将远程仓库克隆到本地

###### 例子

+ cd 

  打开指定文件夹

+ mkdir

  创建文件夹

+ git init

  将当前文件夹初始化为git管理的文件夹

+ 创建一个文件readme.txt 随便写点内容

+ git add 文件名

  将指定文件添加到暂存区当中

+ git commit 

  提交文件，将暂存区中的文件提交到仓库区

+ git status

  获取当前提交状态，可以查看到当前是否存在文件未添加与提交

+ git restore

  在暂存区当中存在文件的情况下，使用该指令可以将暂存区当中的文件撤回工作区（可以理解为 git add 的逆向操作）

+ git log

  打印git提交的记录

+  git log –pretty=oneline 

  简易信息打印

+  git reset --hard HEAD^ 

  现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset --hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^    改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset --hard HEAD~100 即可

   git reset --hard 指定版本号

  可以直接回退到某个指定版本

+  git reflog 

  获取操作已经操作对应的版本号