# CSS

###### vue中的内联样式

​	vue当中的内联样式是以对象的形式进行接收，然后读取对象，将对应key与val转化为String类型，然后将其转义为css内联样式，因此：

+ 由于是传入对象，因此对象的key要满足js的命名规范，最重要的就是js命名不支持 - ，因此在需要传入 - 的情况中，直接使用 " " 将key转化为string类型对象（vue接受到为string类型对象之后会特殊处理）
+ vue会以js的方式读取传入的对象，然后将对应的值以字符串（可能是json）的形式传给css，css也只接受字符串类型的数据，因此vue传出的数据一定是字符串，但是我们传入的数据则不一定，我们可以使用拼接字符串，即在字符串中添加变量，vue读取变量数据并拼接之后，由于格式满足字符串要求，依然会将结果正常的传递给css

###### transition族属性

​	transition族是过渡动画族

​	它会监听一些属性的变化，当监听的属性变化时，会使用预先设置的方式以动画的形式过渡性的改变该属性，而不再是直接生硬的转化，因此被我们用于实现一些简单的动画效果。

+ transition-property：被监听的属性，可以是多个值，当当前选择器的这些属性改变时会触发transition过渡动画效果
+ transition-delay：过渡动画的执行事件，可以携带单位秒（s），毫秒（ms）

###### background族属性

​	顾名思义，background族主要用于设置元素的背景，它本身存在很多好用的特性，可以轻松实现很多其他属性实现比较困难的效果

+ background-img：设置背景图片，很好用

###### 使用组件库组件时，设置css无效？

​	我们在使用组件库组件时，表面上只是使用了一个标签，但是在经过渲染之后，会渲染成为多个不同的标签，有些标签在使用组件的位置是访问不到的，因此我们在使用组件的位置使用css选择器，在该css代码执行的时候，可能根本就没有对应的标签，css选择器选择不到想要的标签，对外就表现为css设置无效

**需要注意，css代码是正常正确运行了的，只是在css代码运行时，选择器找不到对应的html元素（对应html此时还不存在）**

###### 关于flex

flex 即弹性布局

一个flex弹性布局分为两个部分

+ flex容器
+ flex元素

一个容器设置display:flex之后，其子元素都会按照弹性布局的方式进行布局，即子元素在父元素中依次排布（在主轴依次排布）需要注意的是：

+ 在容器设置flex之后，仅仅只会使子元素依次排布，**不会为其添加任何间距**（但是**会保留子元素自己设置的间距，即子元素外边距会保留**），**默认也不会将子元素进行任何的拉伸与收缩**
+ 单独拎出来讲，子元素的外边距是不受flex布局的影响的，换句话说，flex不管怎么搞，反正子元素的外边距设置它必须满足。**不论flex怎么更改元素，都必须满足子元素的外边距设置！**
+ 内边距的设置也一样会被满足，不过与外边距不同的是，本身flex就是对盒模型的整体的操作，而内边距也是属于盒模型之内的

+ 如果子元素没有设置交叉轴方向的长度（可能是高也可能是宽），那么flex会自动将其设置为容器的交叉轴长度（得益于align-content&align-items 的默认值 stretch 会将元素对交叉轴方向进行拉伸）但是如果子元素设置了交叉轴长度，则会以子元素的设置为准

**flex容器常用属性**：

+ flex-direction 设置flex容器的主轴方向（而不是控制子元素的排布方向），注意区别。设置主轴方向的好处在于，很多容器属性是对主轴生效的，这样即使使用flex-direction 改变了方向，我们一样可以使用flex 的容器模型去操作flex容器，例如jusify-content，align-items

+ flex-wrap 设置当子元素宽度过大时是否在主轴方向新增一轴排列元素，使用较少

+ jusifiy-content 设置子元素元素排列之后在主轴仍有剩余空间的情况下，元素如何处理剩余空间

  需要注意的是，只有在子元素排列之后，父元素内部依然存在剩余空间的情况之下，才能通过该方式设置元素之间的

  + left 元素全部靠左排列，空白区全部留到右边
  + center 元素向中间靠拢，空白区在元素左右均分
  + right 元素向右靠拢，空白区全部留到左边

  + space-evenly 元素隔开，且元素与容器边框隔开，类似外边距模式，空白区均分作为间距
  + space-between 元素隔开，但元素与容器边框无距离，空白区均分作为间距
  + space-around 元素隔开，元素与元素间距为元素与边框间距两倍，类似内边距模式，空白区按要求分割

+ align-items 设置元素在交叉轴方向的排布方式与长度设置，我们前面提到，flex容器内部的元素，交叉轴方向的长度会默认变成容器交叉轴方向长度，这就是由于align-items 的设置

+ align-content 也是对交叉轴方向的元素排列方式的设置，与align-items 不同的是，align-content是针对与多行交叉轴的情况的处理，**因此它存在很多只有多行元素才能设置的属性**，例如 space 三件套，它们对单行元素是没有意义的。需要注意的是，由于它是针对交叉轴方向的多行元素，因此需要flex容器设置换行flex-wrap:wrap 之后才有意义

**flex子元素常用属性**

+ flex-grow 当容器中子元素在主轴方向长度不够时，会存在很多留白，如果不想要留白，可以设置该属性不为零，则设置该属性的子元素会在主轴方向拉伸（**所有设置了该属性的子元素都会拉伸，拉伸多少由该属性的值决定**），默认值为0，不拉伸

  **这个属性会使子元素完全占领父元素的留白，这也就意味着它与jusifiy-items之间只有一个会生效**

+ flex-inherit 当容器子元素在主轴方向长度过大，大于主轴长度时，如果不想超出容器，可以设置该元素不为零，子元素会在主轴方向收缩（**所有设置了该属性的子元素都会收缩，收缩程度由该属性的值决定**），默认值为1，即所有需要收缩的子元素收缩之后的主轴长度比为1（收缩之后主轴长度相同）

+ flex-basis 设置子元素在进行flex布局之前的主轴长度，元素在进行flex 布局之前会决定自己的布局主轴长度，是完全由basis决定的，而不是由其width和height决定的，我们之前可以通过width与height进行设置是由于flex-basis 的默认值为auto，即子元素的原本值

+ flex  flex-grow flex-inherit flex-basis 的语法糖缩写

+ align-self 为单个元素设置与其他元素不同的交叉轴对其方式，优先级高于align-items

+ order 设置元素排列顺序，在主轴上，数值越大越靠后

